<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Predictive Analysis of Bankruptcy</title>
    <meta charset="utf-8" />
    <meta name="author" content="Group- V : Adrija Saha, Sampurna Mondal, Shrayan Roy" />
    <meta name="date" content="2023-12-04" />
    <script src="libs/header-attrs-2.16/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <script src="libs/htmlwidgets-1.6.2/htmlwidgets.js"></script>
    <link href="libs/datatables-css-0.0.0/datatables-crosstalk.css" rel="stylesheet" />
    <script src="libs/datatables-binding-0.27/datatables.js"></script>
    <script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
    <link href="libs/dt-core-1.12.1/css/jquery.dataTables.min.css" rel="stylesheet" />
    <link href="libs/dt-core-1.12.1/css/jquery.dataTables.extra.css" rel="stylesheet" />
    <script src="libs/dt-core-1.12.1/js/jquery.dataTables.min.js"></script>
    <link href="libs/crosstalk-1.2.0/css/crosstalk.min.css" rel="stylesheet" />
    <script src="libs/crosstalk-1.2.0/js/crosstalk.min.js"></script>
    <link href="libs/panelset-0.2.6/panelset.css" rel="stylesheet" />
    <script src="libs/panelset-0.2.6/panelset.js"></script>
    <script src="libs/kePrint-0.0.1/kePrint.js"></script>
    <link href="libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
    <script src="libs/rglWebGL-binding-1.1.3/rglWebGL.js"></script>
    <link href="libs/rglwidgetClass-1.1.3/rgl.css" rel="stylesheet" />
    <script src="libs/rglwidgetClass-1.1.3/rglClass.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/utils.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/buffer.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/subscenes.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/shaders.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/shadersrc.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/textures.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/projection.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/mouse.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/init.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/pieces.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/draw.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/controls.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/selection.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/rglTimer.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/pretty.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/axes.src.js"></script>
    <script src="libs/rglwidgetClass-1.1.3/animation.src.js"></script>
    <script src="libs/CanvasMatrix4-1.1.3/CanvasMatrix.src.js"></script>
  </head>
  <body>
    <textarea id="source">

class: center, top
background-image: url("hello.jpeg")
background-size: cover

#Statistical Analysis of Bankrupt firms 
## Based on Financial Indicators
#  
##Group- V: Adrija Saha, Sampurna Mondal, Shrayan Roy
## Date: 12/04/2023

---

# Data Description :

* The dataset considered here, is an Annual financial data of financially sound firms
and the firms which went bankrupt after two years.

--

* It contains 46 observations and 5
columns, where last column is the categorical response variable. Which is 0, if the firm went
.red[**bankrupt**] and 1, if the firm remains .green[**financially sound**].

* 21 observations on bankrupt firms and 25 observations on Financially Sound firms. 

--

* Rest of the four columns are explanatory variables. 

* The explanatory variables provided in this dataset are all continuous. Their names are given by - 

  1. **Ratios of cash flow to total debt (CFTD)**
  
  2. **Ratios of net income to total assets (NITA)**
  
  3. **Ratios of current assets to total liabilities (CATL)**
  
  4. **Ratios of current assets to net sales (CANS)**



&lt;style type="text/css"&gt;
.reduced_opacity {
  opacity: 0.4;
}
.red { color: red; }
.green { color: green; }
.blue { color: blue; }
.scroll-1000 {
  max-height: 400px;
  max-width: 1000px;
  overflow-y: auto;
  background-color: inherit;
}
&lt;/style&gt;


---

# Let's have a look at our dataset 






<div class="datatables html-widget html-fill-item-overflow-hidden html-fill-item" id="htmlwidget-448047509cd87f77512d" style="width:100%;height:auto;"></div>
<script type="application/json" data-for="htmlwidget-448047509cd87f77512d">{"x":{"filter":"none","vertical":false,"fillContainer":false,"data":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46"],[-0.45,-0.56,0.06,-0.07,-0.1,-0.14,0.04,-0.07,0.07,-0.14,-0.23,0.07,0.01,-0.28,0.15,0.37,-0.08,0.05,0.01,0.12,-0.28,0.51,0.08,0.38,0.19,0.32,0.31,0.12,-0.02,0.22,0.17,0.15,-0.1,0.14,0.14,0.15,0.16,0.29,0.54,-0.33,0.48,0.56,0.2,0.47,0.17,0.58],[-0.41,-0.31,0.02,-0.09,-0.09,-0.07,0.01,-0.06,-0.01,-0.14,-0.3,0.02,0,-0.23,0.05,0.11,-0.08,0.03,0,0.11,-0.27,0.1,0.02,0.11,0.05,0.07,0.05,0.05,0.02,0.08,0.07,0.05,-0.01,-0.03,0.07,0.06,0.05,0.06,0.11,-0.09,0.09,0.11,0.08,0.14,0.04,0.04],[1.09,1.51,1.01,1.45,1.56,0.71,1.5,1.37,1.37,1.42,0.33,1.31,2.15,1.19,1.88,1.99,1.51,1.68,1.26,1.14,1.27,2.49,2.01,3.27,2.25,4.24,4.45,2.52,2.05,2.35,1.8,2.17,2.5,0.46,2.61,2.23,2.31,1.84,2.33,3.01,1.24,4.29,1.99,2.92,2.45,5.06],[0.45,0.16,0.4,0.26,0.67,0.28,0.71,0.4,0.34,0.43,0.18,0.25,0.7,0.66,0.27,0.38,0.42,0.95,0.6,0.17,0.51,0.54,0.53,0.35,0.33,0.63,0.69,0.69,0.35,0.4,0.52,0.55,0.58,0.26,0.52,0.56,0.2,0.38,0.48,0.47,0.18,0.44,0.3,0.45,0.14,0.13],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],"container":"<table class=\"display\">\n  <thead>\n    <tr>\n      <th> <\/th>\n      <th>CFTD<\/th>\n      <th>NITA<\/th>\n      <th>CATL<\/th>\n      <th>CANS<\/th>\n      <th>y<\/th>\n    <\/tr>\n  <\/thead>\n<\/table>","options":{"pageLength":10,"columnDefs":[{"className":"dt-right","targets":[1,2,3,4,5]},{"orderable":false,"targets":0}],"order":[],"autoWidth":false,"orderClasses":false}},"evals":[],"jsHooks":[]}</script>

---

# Understanding the meaning of Explanatory variables :

.pull-left[

### • Ratios of cash flow to total debt:
 
This ratio is a type of coverage ratio and can be used to determine how long it would take a company to repay its debt if it devoted all of its cash flow to debt repayment. .red[More the value of the ratio more financially stable it is.]



### • Ratios of net income to total assets:

It refers to a financial ratio that indicates how profitable a company is in relation to its total assets. .red[A higher ROA means a company is more efficient.]

]

.pull-right[

### • Ratios of current assets to total liabilities:

This ratio measures a company’s ability to pay short-term obligations or those due within one year with its total assets.Hence, .red[higher value of this ratio indicates less probable of being bankrupt.]



### • Ratios of current assets to net sales:

This ratio has an inverse relation with current assets turnover.A higher asset turnover ratio means a better percentage of sales.The .red[less the amount of current assets-net sales ratio, the better the ability of the company to generate sales.]

]


---

class: inverse,middle, center

background-image: url("eda_finalcover.png")
background-size: cover

# Exploratory 
# Data Analysis

##(EDA)



---


## Exploratory Data Analysis: Scatterplot  
![](mva_presentation_files/figure-html/unnamed-chunk-4-1.png)&lt;!-- --&gt;

---

## Exploratory Data Analysis: Boxplot

![](mva_presentation_files/figure-html/unnamed-chunk-5-1.png)&lt;!-- --&gt;

---
## Exploratory Data Analysis: Pairwise Comparison

![](mva_presentation_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;
---

## Exploratory Data Analysis: Pairwise Comparison

![](mva_presentation_files/figure-html/unnamed-chunk-7-1.png)&lt;!-- --&gt;

---

## Exploratory Data Analysis: Correlation Plot
* For Bankrupt Firms
![](mva_presentation_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;
---

## Exploratory Data Analysis: Correlation Plot
* For Financial sound Firms
![](mva_presentation_files/figure-html/unnamed-chunk-9-1.png)&lt;!-- --&gt;



---

# Checking Normality in Bankrupt Firms:

.panelset[
.panel[.panel-name[Q-Q Plot]

![](mva_presentation_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;
]

.panel[.panel-name[Shapiro Wilk Test]

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Value of Test Statistic &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; p-Value &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Decision &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CFTD &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.95817 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.48000 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NITA &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.91084 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.05706 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CATL &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.95948 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.50570 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CANS &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.93724 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.19210 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]
]


---
# Checking Normality in Financially sound Firms:
.panelset[
.panel[.panel-name[Q-Q Plot]
![](mva_presentation_files/figure-html/unnamed-chunk-12-1.png)&lt;!-- --&gt;
]
.panel[.panel-name[Shapiro Wilk Test]

&lt;table class=" lightable-paper" style='font-family: "Arial Narrow", arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Value of Test Statistic &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; p-Value &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Decision &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CFTD &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.94170 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.16200 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NITA &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.92382 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.06265 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: red !important;"&gt; CATL &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: red !important;"&gt; 0.90742 &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: red !important;"&gt; 0.02671 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: red !important;"&gt; Reject &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CANS &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.96139 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.44290 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]
]
---
# Chi-Square Plot for checking Multivariate Normality
![](mva_presentation_files/figure-html/unnamed-chunk-14-1.png)&lt;!-- --&gt;

---

#Royston Test : A test of Multivariate Normality :

* Royston’s test uses the Shapiro-Wilk/Shapiro-Francia statistic to test multivariate normality. If kurtosis
of the data is greater than 3, then it uses the Shapiro-Francia test for leptokurtic distributions, otherwise it uses the Shapiro-Wilk test for platykurtic distributions.

* It's implementation is available in .green[**MVN**] package .red[**R**].

* For more details see [MVN: An R Package for Assessing
Multivariate Normality](https://journal.r-project.org/archive/2014-2/korkmaz-goksuluk-zararsiz.pdf)

---

# Test for Multivariate Normality : Royston Test (Bankrupt Firms):

.pull-left[
![](mva_presentation_files/figure-html/unnamed-chunk-15-1.png)&lt;!-- --&gt;
]

.pull-right[

```r
MVN::mvn(data = My.data0[,-5], mvnTest = "royston",univariateTest = "SW",
         desc = FALSE,showOutliers = TRUE,multivariateOutlierMethod = "adj")
```


```
##      Test       H  p value MVN
## 1 Royston 6.04872 0.129197 YES
```

```
##    Observation Mahalanobis Distance Outlier
## 2            2              132.443    TRUE
## 16          16               63.885    TRUE
## 11          11               55.893    TRUE
## 13          13               16.726    TRUE
## 6            6               15.691    TRUE
```
]


---

# Test for Multivariate Normality : Royston Test (Financial Sound Firms):

.pull-left[
![](mva_presentation_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;
]

.pull-right[


```r
MVN::mvn(data = My.data1[,-5], mvnTest = "royston",univariateTest = "SW",
         desc = FALSE,showOutliers = TRUE,multivariateOutlierMethod = "adj")
```


```
##      Test        H    p value MVN
## 1 Royston 12.45531 0.01239924  NO
```

```
##    Observation Mahalanobis Distance Outlier
## 46          46              166.133    TRUE
## 27          27               62.055    TRUE
## 34          34               53.992    TRUE
## 42          42               48.329    TRUE
## 26          26               39.645    TRUE
## 40          40               35.802    TRUE
## 41          41               28.260    TRUE
## 22          22               22.397    TRUE
## 39          39               20.710    TRUE
```
]

---

# A short Note on Robust Mahalanobis Distance :

* Classical Mahalanobis distance is used as a method of detecting outliers.

--

* But it involves estimate of mean vector and variance-covariance matrix.So, affected by outliers !

--

* So, a robust method is used to find estimate of mean vector and variance-covariance matrix. Depending upon choice of estimator, we will get different Robust Mahalanobis Distance


* **R** uses adjusted quantile method based Mahalanobis Distance.

--

* For more details : [Selcuk Korkmaz, Dincer Goksuluk and Gokmen Zararsiz :   MVN: An R Package for Assessing Multivariate Normality](https://journal.r-project.org/archive/2014-2/korkmaz-goksuluk-zararsiz.pdf)


---
class: center, middle
background-image: url("da_cover.png")
background-size: cover
 
# Discriminant Analysis 
---
# Checking Multivariate Normality dropping variables :

.center[* Two Variables at a time ! ]

.panelset[
.panel[.panel-name[Royston Test]
.pull-bottom[.green[Here only we will not include CATL anywhere.Since, taking CATL disturbs univariate normality in 2nd population.]]
.pull-left[

## For Bankrupt firms

&lt;table class=" lightable-paper" style='font-family: "Arial Narrow", arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Variables Included &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Test statistic &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; p-Value &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Decision &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; CFTD,NITA &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 3.151806 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.1168098 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; CFTD,CANS &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 2.737765 &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 0.2543941 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; NITA,CANS &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 5.322533 &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 0.0698239 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]

.pull-right[

## For Financially sound firms

&lt;table class=" lightable-paper" style='font-family: "Arial Narrow", arial, helvetica, sans-serif; width: auto !important; margin-left: auto; margin-right: auto;'&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt;   &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Variables Included &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Test statistic &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; p-Value &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Decision &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; CFTD,NITA &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 6.122089 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.0392588 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Reject &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; CFTD,CANS &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 2.735482 &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 0.2545416 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; 6 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; NITA,CANS &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 5.146921 &lt;/td&gt;
   &lt;td style="text-align:right;font-weight: bold;font-style: italic;color: green !important;"&gt; 0.0762711 &lt;/td&gt;
   &lt;td style="text-align:left;font-weight: bold;font-style: italic;color: green !important;"&gt; Accept &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

]

]

.panel[.panel-name[Chi-Square Plots for CFTD &amp; CANS]

&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-23-1.png" style="display: block; margin: auto;" /&gt;

]

.panel[.panel-name[Chi-Square Plots for NITA &amp; CANS]

&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-24-1.png" style="display: block; margin: auto;" /&gt;

]
]

---

# Analysis with CFTD &amp; CANS :

.panelset[
.panel[.panel-name[ .red[Box-M Test and MANOVA]]

.pull-top[


```r
heplots::boxM(as.matrix(My.data[,-c(2,3,5)]) ~ as.factor(y),data = My.data)
```

```
## 
## 	Box's M-test for Homogeneity of Covariance Matrices
## 
## data:  Y
## Chi-Sq (approx.) = 2.3791, df = 3, p-value = 0.4975
```
]

.pull-bottom[


```r
model.manova &lt;- manova(cbind(CFTD,CANS)~y,data = My.data)
summary(model.manova)
```

```
##           Df  Pillai approx F num Df den Df    Pr(&gt;F)    
## y          1 0.34432    11.29      2     43 0.0001145 ***
## Residuals 44                                             
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```
]

]

.panel[.panel-name[ .red[LDA]]

.pull-left[


```r
lda(My.data[,-c(2,3,5)],My.data$y)
```

```
## Call:
## lda(My.data[, -c(2, 3, 5)], My.data$y)
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          CFTD     CANS
## 0 -0.06904762 0.437619
## 1  0.23520000 0.426800
## 
## Coefficients of linear discriminants:
##             LD1
## CFTD 4.67736451
## CANS 0.01965838
```
]

.pull-right[

![](mva_presentation_files/figure-html/unnamed-chunk-28-1.png)&lt;!-- --&gt;

]

]

.panel[.panel-name[ .red[Performance]]

.pull-left[
![](mva_presentation_files/figure-html/unnamed-chunk-29-1.png)&lt;!-- --&gt;
]

.pull-right[

.red[Training Set Performance]

```r
table(Actual = My.data[,5], Predicted = predict(lda(My.data[,-c(2,3,5)],My.data$y))$class)
```

```
##       Predicted
## Actual  0  1
##      0 15  6
##      1  3 22
```

.red[AER Estimate (Cross Validated)]

```r
aer(My.data[,5], Lda_Model.1$class)
```

```
## [1] 0.2391304
```

]

]

]

---

# Analysis with NITA &amp; CANS:
.panelset[
.panel[.panel-name[ .red[Box-M Test]]



```r
heplots::boxM(as.matrix(My.data[,-c(1,3,5)]) ~ as.factor(y),data = My.data)
```

```
## 
## 	Box's M-test for Homogeneity of Covariance Matrices
## 
## data:  Y
## Chi-Sq (approx.) = 23.435, df = 3, p-value = 3.277e-05
```

]

.panel[.panel-name[ .red[QDA]]



```r
qda(My.data[,-c(1,3,5)],My.data$y)
```

```
## Call:
## qda(My.data[, -c(1, 3, 5)], My.data$y)
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          NITA     CANS
## 0 -0.08142857 0.437619
## 1  0.05560000 0.426800
```

]

.panel[.panel-name[ .red[Performance]]

.pull-left[
![](mva_presentation_files/figure-html/unnamed-chunk-34-1.png)&lt;!-- --&gt;
]

.pull-right[

.red[Training Set Performance]

```r
table(Actual = My.data[,5], Predicted = predict(qda(My.data[,-c(1,3,5)],My.data$y))$class)
```

```
##       Predicted
## Actual  0  1
##      0 12  9
##      1  2 23
```

.red[AER Estimate (Cross Validated)]

```r
aer(My.data[,5], Qda_Model.2$class)
```

```
## [1] 0.2608696
```

]

]

]

---
# Checking Multivariate Normality dropping variables :

* Three Variables at a time! 


.panelset[
.panel[.panel-name[Royston Test]
.pull-bottom[.green[Here only we will check dropping CATL.Since, taking CATL disturbs univariate normality in 2nd population.]]
* For Bankrupt Firms

```r
MVN::mvn(My.data[My.data$y == 0,-c(3,5)],mvnTest = "royston")$multivariateNormality
```

```
##      Test        H   p value MVN
## 1 Royston 4.823069 0.1128417 YES
```

* For Financial sound Firms

```r
MVN::mvn(My.data[My.data$y == 0,-c(3,5)],mvnTest = "royston")$multivariateNormality
```

```
##      Test        H   p value MVN
## 1 Royston 4.823069 0.1128417 YES
```

]


.panel[.panel-name[Chi-Square Plot for CFTD,NITA &amp; CANS]
&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-39-1.png" style="display: block; margin: auto;" /&gt;
]
]

---

# Analysis with CFTD, NITA &amp; CANS:
.panelset[
.panel[.panel-name[ .red[Box-M Test]]



```r
heplots::boxM(as.matrix(My.data[,-c(3,5)]) ~ as.factor(y),data = My.data)
```

```
## 
## 	Box's M-test for Homogeneity of Covariance Matrices
## 
## data:  Y
## Chi-Sq (approx.) = 46.237, df = 6, p-value = 2.655e-08
```

]

.panel[.panel-name[ .red[QDA]]



```r
qda(My.data[,-c(3,5)],My.data$y)
```

```
## Call:
## qda(My.data[, -c(3, 5)], My.data$y)
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          CFTD        NITA     CANS
## 0 -0.06904762 -0.08142857 0.437619
## 1  0.23520000  0.05560000 0.426800
```

]

.panel[.panel-name[ .red[Performance]]


.red[Training Set Performance]



```r
table(Actual = My.data[,5], Predicted = predict(lda(My.data[,-c(3,5)],My.data$y))$class)
```

```
##       Predicted
## Actual  0  1
##      0 13  8
##      1  3 22
```

.red[AER Estimate (Cross Validated)]

```r
aer(My.data[,5], Qda_Model.3$class)
```

```
## [1] 0.2173913
```

]

]

---

#Transformation for Multivariate Normality :

* **Box-Cox Transformation** is a commonly used transformation for normality.

--

* But, Applicability of this is restricted to positive valued variables only.

--

* [Yeo-Johnson :A New Family of Power Transformations to Improve Normality or Symmetry](https://www.jstor.org/stable/2673623) suggested a generalized Box-cox transformation. Which is defined as - 

`$$\psi(y,\lambda)=\begin{cases}\frac{(y+1)^\lambda - 1}{\lambda},&amp; y\ge0,\lambda\not=0\\log(y+1),&amp; y\ge0,\lambda=0\\-\frac{(-y+1)^{2-\lambda}-1}{2-\lambda},&amp;y&lt;0,\lambda\not=2\\-log(-y+1),&amp;y&lt;0,\lambda=2\end{cases}$$`

* We will use this to transformation to achieve normality of third variable. 

* To obtain Optimal `\(\lambda\)`, we will use likelihood based approach. 


---
# Transforming CATL for Financially sound firms:


.panelset[
.panel[.panel-name[ Finding Optimum lambda ]


&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-46-1.png" style="display: block; margin: auto;" /&gt;

```
##   Optimal Lambda Likelihood Value 
##          0.41000        -34.83718
```

]

.panel[.panel-name[Test for Multivariate Normality]

* After transformation:




```r
MVN::mvn(data = My.data_trans0[My.data_trans0$y == 1,-5], mvnTest = "royston",
         univariateTest = "SW", desc = FALSE)
```

```
## $multivariateNormality
##      Test        H    p value MVN
## 1 Royston 11.19854 0.02137175  NO
## 
## $univariateNormality
##           Test  Variable Statistic   p value Normality
## 1 Shapiro-Wilk   CFTD       0.9417    0.1620    YES   
## 2 Shapiro-Wilk   NITA       0.9238    0.0626    YES   
## 3 Shapiro-Wilk   CATL       0.9256    0.0688    YES   
## 4 Shapiro-Wilk   CANS       0.9614    0.4429    YES
```

.red[Multivariate Normality Rejected ! ]

]
]

---
# Finding Optimum `\(\lambda\)` based on joint likelihood:


---
# Transforming CATL maximing joint likelihood:


```r
g.boxcox&lt;- function(data0,data1,lambda.seq){
  
  #used to calculate joint likelihood 
  lbc.mv &lt;- function(lambda.1){
  l.gbc(data0,lambda.1)+l.gbc(data1,lambda.1)
  #l.gbc calculates likelihood based on Yeo-Johnson
  }
  
  #plot of likelihood vs. lambda graph...
  plot(lambda.seq,vapply(lambda.seq, FUN = lbc.mv, FUN.VALUE = 2),
       col = "red",type = "l",xlab = "Lambda",ylab = "Log Likelihood",
       main = "Plot of Log Likelihood vs. Lambda",lwd = 3)
  
  #adding reference line...
  abline(h = max(vapply(lambda.seq, FUN = lbc.mv, FUN.VALUE = 2)) - 0.5,lty = 2,col = "blue",lwd = 2)
  abline(v = lambda.seq[which.max(vapply(lambda.seq, FUN = lbc.mv, FUN.VALUE = 2))],lty = 2,col = "blue",lwd = 2)
  
  #Printing the value of optimal lambda...
print(c("Optimal Lambda" = lambda.seq[which.max(vapply(lambda.seq, FUN = lbc.mv, FUN.VALUE = 2))],
          "Likelihood Value" = max(vapply(lambda.seq, FUN = lbc.mv, FUN.VALUE = 2))))
  
}
```

---

# Transforming CATL by maximizing joint likelihood:

.panelset[
.panel[.panel-name[ Finding Optimum lambda ]


&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-50-1.png" style="display: block; margin: auto;" /&gt;

```
##   Optimal Lambda Likelihood Value 
##          0.72000        -45.66093
```

]

.panel[.panel-name[For Bankrupt Firms]

* After transformation:




```r
MVN::mvn(data = My.data_trans2[My.data_trans2$y == 0,-5], mvnTest = "royston",
         univariateTest = "SW", desc = FALSE)
```

```
## $multivariateNormality
##      Test        H    p value MVN
## 1 Royston 6.668277 0.09935673 YES
## 
## $univariateNormality
##           Test  Variable Statistic   p value Normality
## 1 Shapiro-Wilk   CFTD       0.9582    0.4800    YES   
## 2 Shapiro-Wilk   NITA       0.9108    0.0571    YES   
## 3 Shapiro-Wilk   CATL       0.9487    0.3222    YES   
## 4 Shapiro-Wilk   CANS       0.9372    0.1921    YES
```

.green[Multivariate Normality Accepted ! ]

]
.panel[.panel-name[For Financially sound Firms]
* After transformation:


```r
MVN::mvn(data = My.data_trans2[My.data_trans2$y == 1,-5], mvnTest = "royston",
         univariateTest = "SW", desc = FALSE)
```

```
## $multivariateNormality
##      Test        H   p value MVN
## 1 Royston 11.46395 0.0190663  NO
## 
## $univariateNormality
##           Test  Variable Statistic   p value Normality
## 1 Shapiro-Wilk   CFTD       0.9417    0.1620    YES   
## 2 Shapiro-Wilk   NITA       0.9238    0.0626    YES   
## 3 Shapiro-Wilk   CATL       0.9205    0.0527    YES   
## 4 Shapiro-Wilk   CANS       0.9614    0.4429    YES
```

.red[Multivariate Normality Rejected ! ]
]
]

---

# Multivariate version of Yeo-Johnson family of Transformation:

* Univariate transformation is not helping much !

--

* .green[**Solution**]: Multivariate version of **Yeo-Johnson Transformation**. 

--

* Implementation is available in **R**, .green[**powerTransform**] function of .red[car] package.

--

* Let's try to implement this transformation on Financially Sound Firms first. 


---

# Using Multivariate Yeo-Johnson transformation :

.panelset[
.panel[.panel-name[ Finding Optimum lambda ]



```r
lambda.2 &lt;- car::powerTransform(as.matrix(My.data1[,-5]),family = "yjPower")
lambda.2
```

```
## Estimated transformation parameters 
##      CFTD      NITA      CATL      CANS 
## 1.2504445 5.3233515 0.6919768 1.7079405
```



]

.panel[.panel-name[For Bankrupt Firms]

* After transformation:


```r
MVN::mvn(data = My.data_trans4[My.data_trans4$y == 0,-5], mvnTest = "royston",
         univariateTest = "SW", desc = FALSE)
```

```
## $multivariateNormality
##      Test       H  p value MVN
## 1 Royston 4.99441 0.200548 YES
## 
## $univariateNormality
##           Test   Variable Statistic   p value Normality
## 1 Shapiro-Wilk CFTD_Trans    0.9637    0.5927    YES   
## 2 Shapiro-Wilk NITA_Trans    0.9571    0.4596    YES   
## 3 Shapiro-Wilk CATL_Trans    0.9474    0.3045    YES   
## 4 Shapiro-Wilk CANS_Trans    0.9186    0.0813    YES
```

.green[Multivariate Normality Accepted ! ]

]
.panel[.panel-name[For Financially sound Firms]
* After transformation:


```r
MVN::mvn(data = My.data_trans4[My.data_trans4$y == 1,-5], mvnTest = "royston",
         univariateTest = "SW", desc = FALSE)
```

```
## $multivariateNormality
##      Test        H   p value MVN
## 1 Royston 6.981046 0.1261358 YES
## 
## $univariateNormality
##           Test   Variable Statistic   p value Normality
## 1 Shapiro-Wilk CFTD_Trans    0.9454    0.1970    YES   
## 2 Shapiro-Wilk NITA_Trans    0.9714    0.6809    YES   
## 3 Shapiro-Wilk CATL_Trans    0.9214    0.0552    YES   
## 4 Shapiro-Wilk CANS_Trans    0.9663    0.5539    YES
```

.green[Multivariate Normality Accepted ! ]
]

.panel[.panel-name[Chisqaure Plot]

&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-58-1.png" style="display: block; margin: auto;" /&gt;
]

]

---

# Analysis Using All Transformed Variables:

.panelset[
.panel[.panel-name[ .red[Box-M Test]]



```r
heplots::boxM(as.matrix(My.data_trans4[,-5]) ~ as.factor(y),data = My.data_trans4)
```

```
## 
## 	Box's M-test for Homogeneity of Covariance Matrices
## 
## data:  Y
## Chi-Sq (approx.) = 35.987, df = 10, p-value = 8.462e-05
```

]

.panel[.panel-name[ .red[QDA]]



```r
qda(My.data_trans4[,-5],My.data_trans4$y)
```

```
## Call:
## qda(My.data_trans4[, -5], My.data_trans4$y)
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##    CFTD_Trans  NITA_Trans CATL_Trans CANS_Trans
## 0 -0.06391799 -0.04291975   1.169570  0.5162760
## 1  0.24660291  0.06830228   2.028308  0.4970221
```

]

.panel[.panel-name[ .red[Performance]]



.red[Training Set Performance]

```r
table(Actual = My.data[,5], Predicted = predict(qda(My.data_trans4[,-5],My.data_trans4$y))$class)
```

```
##       Predicted
## Actual  0  1
##      0 19  2
##      1  1 24
```

.red[AER Estimate (Cross Validated)]

```r
aer(My.data[,5], Qda_Model.4$class)
```

```
## [1] 0.1521739
```

.green[**Less than the all previous models !**]

]



]

---
# Is their any better possible classifier with less variables :

* Less number of variables in a model is always good!


--

* Unless and until we are sacrificing much on misclassification error rate.


--

* Already discussed some discriminant rules after dropping variables.

--

* Now, let us see after transformation how are the performances of some other rules.

--

* Here, we will judge based on Leave-one out cross-validation apparent error rate. 


--

* First, let's drop one Variable at a time! 



---

# Transforming CFTD,NITA,CATL :

.panelset[
.panel[.panel-name[ Finding Optimum lambda ]



```r
lambda.6 &lt;- car::powerTransform(as.matrix(My.data1[,-c(4,5)]),family = "yjPower")
lambda.6
```

```
## Estimated transformation parameters 
##      CFTD      NITA      CATL 
## 1.1222010 5.4300750 0.6541604
```



]

.panel[.panel-name[For Bankrupt Firms]

* After transformation:


```r
MVN::mvn(with(My.data[My.data$y == 0,],yjPower(cbind(CFTD,NITA,CATL),coef(lambda.6))), mvnTest = "royston",
         univariateTest = "SW", desc = FALSE)
```

```
## $multivariateNormality
##      Test        H   p value MVN
## 1 Royston 2.705383 0.3148556 YES
## 
## $univariateNormality
##           Test  Variable Statistic   p value Normality
## 1 Shapiro-Wilk CFTD^1.12    0.9611    0.5390    YES   
## 2 Shapiro-Wilk NITA^5.43    0.9566    0.4510    YES   
## 3 Shapiro-Wilk CATL^0.65    0.9457    0.2812    YES
```

.green[Multivariate Normality Accepted ! ]

]
.panel[.panel-name[For Financially sound Firms]
* After transformation:


```r
MVN::mvn(with(My.data[My.data$y == 1,],yjPower(cbind(CFTD,NITA,CATL),coef(lambda.6))), mvnTest = "royston",
         univariateTest = "SW", desc = FALSE)
```

```
## $multivariateNormality
##      Test        H    p value MVN
## 1 Royston 6.616813 0.07627823 YES
## 
## $univariateNormality
##           Test  Variable Statistic   p value Normality
## 1 Shapiro-Wilk CFTD^1.12    0.9438    0.1809    YES   
## 2 Shapiro-Wilk NITA^5.43    0.9720    0.6952    YES   
## 3 Shapiro-Wilk CATL^0.65    0.9225    0.0585    YES
```

.green[Multivariate Normality Accepted ! ]
]

]

---

#Analysis taking CFTD, NITA, CATL(after transformation) :

.panelset[
.panel[.panel-name[ .red[Box-M Test]]



```r
heplots::boxM(as.matrix(My.data_trans6[,c(1,2,3)]) ~ as.factor(y),data = My.data_trans6)
```

```
## 
## 	Box's M-test for Homogeneity of Covariance Matrices
## 
## data:  Y
## Chi-Sq (approx.) = 27.858, df = 6, p-value = 9.994e-05
```

]

.panel[.panel-name[ .red[QDA]]



```r
qda(My.data_trans6[,c(1,2,3)], My.data_trans6[,5])
```

```
## Call:
## qda(My.data_trans6[, c(1, 2, 3)], My.data_trans6[, 5])
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          CFTD        NITA     CATL
## 0 -0.06652109 -0.04223014 1.147983
## 1  0.24068187  0.06865672 1.970263
```

]

.panel[.panel-name[ .red[Performance]]



.red[Training Set Performance]

```r
table(Actual = My.data_trans6[,5], Predicted = predict(qda(My.data_trans6[,c(1,2,3)], My.data_trans6[,5]))$class)
```

```
##       Predicted
## Actual  0  1
##      0 17  4
##      1  2 23
```

.red[AER Estimate (Cross Validated)]


```r
aer(My.data[,5], Qda_Model.6$class)
```

```
## [1] 0.1521739
```

.green[**Same as taking all four variables !**]

]

]

---

# Transforming CFTD,CATL,CANS:

.red[To bring multivariate normality, we will use optimum]  `\(\lambda\)` =0.72 
.red[for transforming CATL.]

.panelset[
.panel[.panel-name[For Bankrupt Firms]

* After transformation:


```r
MVN::mvn(My.data_trans2[My.data_trans2$y == 0,-c(2,5)],mvnTest = "royston",univariateTest = "SW", 
         desc = F)
```

```
## $multivariateNormality
##      Test        H   p value MVN
## 1 Royston 4.605265 0.2059711 YES
## 
## $univariateNormality
##           Test  Variable Statistic   p value Normality
## 1 Shapiro-Wilk   CFTD       0.9582    0.4800    YES   
## 2 Shapiro-Wilk   CATL       0.9487    0.3222    YES   
## 3 Shapiro-Wilk   CANS       0.9372    0.1921    YES
```

.green[Multivariate Normality Accepted ! ]

]
.panel[.panel-name[For Financially sound Firms]
* After transformation:



```r
MVN::mvn(My.data_trans2[My.data_trans2$y == 1,-c(2,5)],mvnTest = "royston",univariateTest = "SW", 
         desc = F)
```

```
## $multivariateNormality
##      Test        H    p value MVN
## 1 Royston 7.449324 0.05910793 YES
## 
## $univariateNormality
##           Test  Variable Statistic   p value Normality
## 1 Shapiro-Wilk   CFTD       0.9417    0.1620    YES   
## 2 Shapiro-Wilk   CATL       0.9205    0.0527    YES   
## 3 Shapiro-Wilk   CANS       0.9614    0.4429    YES
```

.green[Multivariate Normality Accepted ! ]
]

]

---

#Analysis taking CFTD, CATL, CANS(after transformation) :

.panelset[
.panel[.panel-name[ .red[Box-M Test]]



```r
heplots::boxM(as.matrix(My.data_trans2[,-c(2,5)]) ~ as.factor(y),data = My.data_trans2)
```

```
## 
## 	Box's M-test for Homogeneity of Covariance Matrices
## 
## data:  Y
## Chi-Sq (approx.) = 16.082, df = 6, p-value = 0.01332
```

]

.panel[.panel-name[ .red[QDA]]



```r
qda(My.data_trans2[,-c(2,5)],My.data_trans2$y)
```

```
## Call:
## qda(My.data_trans2[, -c(2, 5)], My.data_trans2$y)
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          CFTD     CATL     CANS
## 0 -0.06904762 1.185911 0.437619
## 1  0.23520000 2.072756 0.426800
```

]

.panel[.panel-name[ .red[Performance]]



.red[Training Set Performance]

```r
table(Actual = My.data_trans2[,5], Predicted = predict(qda(My.data_trans2[,-c(2,5)],My.data_trans2$y))$class)
```

```
##       Predicted
## Actual  0  1
##      0 19  2
##      1  1 24
```

.red[AER Estimate (Cross Validated)]

```r
aer(My.data_trans2[,5], Qda_Model.7$class)
```

```
## [1] 0.1304348
```

.green[**Even, Better than including all four transformed variables !**]

]

]

---

#Results of other case :

* When we tried to transform NITA, CATL, CANS, neither Univariate nor Multivariate transformations help!

** Table of results of taking 2 variables at a time:**
(Which were not discussed previously)

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:left;"&gt; Subsets &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Transformation &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Box-M p-Value &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; QDA CV AER estimate &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CFTD &amp;amp; NITA &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Multivariate &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.001785 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.2391304 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CFTD &amp;amp; CATL &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Not possible &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; NA &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; NA &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; NITA &amp;amp; CATL &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Multivariate &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.015010 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.1304348 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:left;"&gt; CATL &amp;amp; CANS &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Univariate &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.002709 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0.1521739 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

.red[Only transformed NITA &amp; transformed CATL is producing the lowest estimate of AER amongst all!]

.green[Optimum] `\(\lambda\)`
.green[ for this transformation is ]

```
## Estimated transformation parameters 
##      NITA      CATL 
## 7.5873497 0.3379119
```
---

# Analysis Using Transformed NITA and Transformed CATL: 

.pull-left[





```r
qda(My.data_trans51[,c(2,3)], My.data_trans51[,5])
```

```
## Call:
## qda(My.data_trans51[, c(2, 3)], My.data_trans51[, 5])
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          NITA      CATL
## 0 -0.02994461 0.9864808
## 1  0.07632512 1.5606233
```
]

.pull-right[

![](mva_presentation_files/figure-html/unnamed-chunk-84-1.png)&lt;!-- --&gt;
]

---

# Principal Component Analysis :

.panelset[
.panel[.panel-name[ .red[PCA]]

.pull-left[



```r
pca &lt;- prcomp(My.data[,-5],scale = T)
pca
```

```
## Standard deviations (1, .., p=4):
## [1] 1.5121409 1.0187432 0.7437780 0.3498378
## 
## Rotation (n x k) = (4 x 4):
##             PC1         PC2        PC3        PC4
## CFTD 0.62014111 -0.17691691  0.1967033 -0.7385345
## NITA 0.59989827 -0.08361003  0.4630444  0.6470868
## CATL 0.50193544  0.20371413 -0.8266216  0.1525063
## CANS 0.06006574  0.95927594  0.2521796 -0.1121929
```
]
.pull-right[

&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-87-1.png" style="display: block; margin: auto;" /&gt;

]

]


.panel[.panel-name[ .red[Plots]]

.pull-left[
&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-88-1.png" style="display: block; margin: auto;" /&gt;
]

.pull-right[
&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-89-1.png" style="display: block; margin: auto;" /&gt;

```
## [1] Cum Prop. Explained: 0.57,0.83,0.96,1
```

]

]

]



---

## 3D Plots w.r.t. first three Principal Components :



.pull-middle[
<div id="rgl40975" style="width:504px;height:504px;" class="rglWebGL html-widget "></div>
<script type="application/json" data-for="rgl40975">{"x":{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmode":"modulate","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0],"margin":"","floating":false,"tag":"","blend":["src_alpha","one_minus_src_alpha"]},"rootSubscene":7,"objects":{"13":{"id":13,"type":"spheres","material":{},"vertices":"0","colors":"1","radii":[[0.100000001490116]],"centers":"2","ignoreExtent":false,"fastTransparency":true,"flags":32771},"15":{"id":15,"type":"text","material":{"lit":false,"margin":0,"floating":true,"edge":[0,1,1]},"vertices":"3","colors":"4","texts":[["PC1"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"5","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"16":{"id":16,"type":"text","material":{"lit":false,"margin":1,"floating":true,"edge":[1,1,1]},"vertices":"6","colors":"7","texts":[["PC2"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"8","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"17":{"id":17,"type":"text","material":{"lit":false,"margin":2,"floating":true,"edge":[1,1,1]},"vertices":"9","colors":"10","texts":[["PC3"]],"cex":[[1]],"adj":[[0.5,0.5,0.5]],"centers":"11","family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":33808},"11":{"id":11,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"10":{"id":10,"type":"background","material":{},"colors":"12","centers":"13","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"12":{"id":12,"type":"background","material":{"lit":false,"back":"lines"},"colors":"14","centers":"15","sphere":false,"fogtype":"none","fogscale":1,"flags":32768},"14":{"id":14,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":"16","colors":"17","axes":{"mode":["pretty","pretty","pretty"],"step":[1,1,1],"nticks":[5,5,5],"marklen":[15,15,15],"expand":[1.02999997138977,1.02999997138977,1.02999997138977]},"draw_front":true,"flags":32769},"7":{"id":7,"type":"subscene","par3d":{"antialias":8,"FOV":30,"ignoreExtent":false,"listeners":7,"mouseMode":{"none":"none","left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,21.8949146270752],"modelMatrix":[[0.763060033321381,0,0,0.349998116493225],[0,0.383232265710831,1.34783697128296,0.685867190361023],[0,-1.05292201042175,0.490572541952133,-21.1460876464844],[0,0,0,1]],"projMatrix":[[3.73205065727234,0,0,0],[0,3.73205065727234,0,0],[0,0,-3.86370325088501,-78.9286346435547],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.342020143325668,0.939692620785909,0],[0,-0.939692620785909,0.342020143325668,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[0.763060033321381,1.12049615383148,1.43433809280396],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-3.84367036819458,2.92631649971008,-1.88654494285583,2.72382879257202,-2.4286961555481,1.17289984226227],"windowRect":[138,161,394,417],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"TT Arial","maxClipPlanes":8,"glVersion":4.6,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[12,14,13,15,16,17,11],"subscenes":[],"flags":34067}},"crosstalk":{"key":[],"group":[],"id":[],"options":[]},"width":504,"height":504,"buffer":{"accessors":[{"bufferView":0,"componentType":5126,"count":46,"type":"VEC3"},{"bufferView":1,"componentType":5121,"count":46,"type":"VEC4","normalized":true},{"bufferView":2,"componentType":5126,"count":46,"type":"VEC3"},{"bufferView":3,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":4,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":5,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":6,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":7,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":8,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":9,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":10,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":11,"componentType":5126,"count":1,"type":"VEC3"},{"bufferView":12,"componentType":5126,"count":1,"type":"VEC4"},{"bufferView":13,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":14,"componentType":5121,"count":1,"type":"VEC4"},{"bufferView":15,"componentType":5121,"count":1,"type":"VEC3"},{"bufferView":16,"componentType":5126,"count":14,"type":"VEC3"},{"bufferView":17,"componentType":5121,"count":1,"type":"VEC4"}],"bufferViews":[{"buffer":0,"byteLength":552,"byteOffset":0},{"buffer":0,"byteLength":184,"byteOffset":552},{"buffer":0,"byteLength":552,"byteOffset":736},{"buffer":0,"byteLength":12,"byteOffset":1288},{"buffer":0,"byteLength":4,"byteOffset":1300},{"buffer":0,"byteLength":12,"byteOffset":1304},{"buffer":0,"byteLength":12,"byteOffset":1316},{"buffer":0,"byteLength":4,"byteOffset":1328},{"buffer":0,"byteLength":12,"byteOffset":1332},{"buffer":0,"byteLength":12,"byteOffset":1344},{"buffer":0,"byteLength":4,"byteOffset":1356},{"buffer":0,"byteLength":12,"byteOffset":1360},{"buffer":0,"byteLength":16,"byteOffset":1372},{"buffer":0,"byteLength":3,"byteOffset":1388},{"buffer":0,"byteLength":4,"byteOffset":1391},{"buffer":0,"byteLength":3,"byteOffset":1395},{"buffer":0,"byteLength":168,"byteOffset":1400},{"buffer":0,"byteLength":4,"byteOffset":1568}],"buffers":[{"byteLength":1572,"bytes":"jZttwDvSCz/mBI+/aQBYwMVUX7+wysi/Wvfzvqtsu76f1F4//mmSv+sQWL9xF0S+EmWDv+3K\nqj8tmIM+FbTJv44MW78hZO4+Y19ovi0irz8gEVc/bS5+v6TJGr6WQzY+zj/gvi+gF7/pscY+\nSXzBv13Y7j0GvjG+Ef1HwMdhnr8CkZK+aEK0vmr3i7/aM9o+pXfSvCLFvD8JOG4+SnAUwN08\ntj8IJuS9TDuMPg/Jcr+ZkSE+KbiWP7PqCr9kohs/xr+EvzLO1DpkowU8+ZF8PQCdKEALNY0/\n34sAv9YSRj8ynVM/gyq7PZvR0b+YglQ/EmghwHF/Lz8xLQi/uq3hPxCZmz7OE/g+gozlPT37\n/z7lEng+5DXqP6Ks5L4qIfS+Fq4SP2iKFr91ZQq9E2YEQPBPoz8+1Yq/eqMEQEZa0z9J66C/\ncqYoP77UsT9NKD0+rhwovopBub7xOOa9SbNcP3mVeb7Duuo9Pm/rPoUPnz4/1ic/koQCPyuh\nET8oKZs+jrtMvnI6gD/Qv62+wDJZv6ASnb9qf4A/V+JKP2Rn/T6k6wO9CGcXP8pYID/dEZw+\nmX36Pj3Lnb8lP5G+mLMrP4Vb+L4i2vc+ekbkP253i70I/hc/Fjdqv2LmPT/hwrC/HBdnP+MN\n5r8SSnU/oOUyQPR42j3fH4e/ezsaP9HuUr/gOoQ+i/4CQKxFn70XfgI+RMwDP0Utwr/puQK/\nt1syQC/JqL99+RbA/xST//8Uk///FJP//xST//8Uk///FJP//xST//8Uk///FJP//xST//8U\nk///FJP//xST//8Uk///FJP//xST//8Uk///FJP//xST//8Uk///FJP/AJrN/wCazf8Ams3/\nAJrN/wCazf8Ams3/AJrN/wCazf8Ams3/AJrN/wCazf8Ams3/AJrN/wCazf8Ams3/AJrN/wCa\nzf8Ams3/AJrN/wCazf8Ams3/AJrN/wCazf8Ams3/AJrN/42bbcA70gs/5gSPv2kAWMDFVF+/\nsMrIv1r3876rbLu+n9ReP/5pkr/rEFi/cRdEvhJlg7/tyqo/LZiDPhW0yb+ODFu/IWTuPmNf\naL4tIq8/IBFXP20ufr+kyRq+lkM2Ps4/4L4voBe/6bHGPkl8wb9d2O49Br4xvhH9R8DHYZ6/\nApGSvmhCtL5q94u/2jPaPqV30rwixbw/CThuPkpwFMDdPLY/CCbkvUw7jD4PyXK/mZEhPim4\nlj+z6gq/ZKIbP8a/hL8yztQ6ZKMFPPmRfD0AnShACzWNP9+LAL/WEkY/Mp1TP4Mquz2b0dG/\nmIJUPxJoIcBxfy8/MS0Iv7qt4T8QmZs+zhP4PoKM5T09+/8+5RJ4PuQ16j+irOS+KiH0vhau\nEj9oiha/dWUKvRNmBEDwT6M/PtWKv3qjBEBGWtM/Seugv3KmKD++1LE/TSg9Pq4cKL6KQbm+\n8TjmvUmzXD95lXm+w7rqPT5v6z6FD58+P9YnP5KEAj8roRE/KCmbPo67TL5yOoA/0L+tvsAy\nWb+gEp2/an+AP1fiSj9kZ/0+pOsDvQhnFz/KWCA/3RGcPpl9+j49y52/JT+RvpizKz+FW/i+\nItr3PnpG5D9ud4u9CP4XPxY3ar9i5j0/4cKwvxwXZz/jDea/Ekp1P6DlMkD0eNo93x+Hv3s7\nGj/R7lK/4DqEPov+AkCsRZ+9F34CPkTMAz9FLcK/6bkCv7dbMkAvyai/ffkWwAAAwH8AAIBA\nAACAPwAAAAEAAMB/AACAQAAAgD8AAMB/AACAQAAAgD8AAAABAADAfwAAgEAAAIA/AADAfwAA\ngEAAAIA/AAAAAQAAwH8AAIBAAACAP5mYmD6ZmJg+mZiYPgAAgD8AAAABAQEBAAAAAAAAAEDA\nAADAfwAAwH8AAADAAADAfwAAwH8AAIC/AADAfwAAwH8AAAAAAADAfwAAwH8AAIA/AADAfwAA\nwH8AAABAAADAfwAAwH8AAMB/AACAvwAAwH8AAMB/AAAAAAAAwH8AAMB/AACAPwAAwH8AAMB/\nAAAAQAAAwH8AAMB/AADAfwAAAMAAAMB/AADAfwAAgL8AAMB/AADAfwAAAAAAAMB/AADAfwAA\ngD8AAAAB"}]},"context":{"shiny":false,"rmarkdown":"xaringan::moon_reader"},"vertexShader":"#line 2 1\n// File 1 is the vertex shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\n\nattribute vec3 aPos;\nattribute vec4 aCol;\nuniform mat4 mvMatrix;\nuniform mat4 prMatrix;\nvarying vec4 vCol;\nvarying vec4 vPosition;\n\n#ifdef NEEDS_VNORMAL\nattribute vec3 aNorm;\nuniform mat4 normMatrix;\nvarying vec4 vNormal;\n#endif\n\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nattribute vec2 aTexcoord;\nvarying vec2 vTexcoord;\n#endif\n\n#ifdef FIXED_SIZE\nuniform vec3 textScale;\n#endif\n\n#ifdef FIXED_QUADS\nattribute vec3 aOfs;\n#endif\n\n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\nvarying float normz;\nuniform mat4 invPrMatrix;\n#else\nattribute vec3 aPos1;\nattribute vec3 aPos2;\nvarying float normz;\n#endif\n#endif // IS_TWOSIDED\n\n#ifdef FAT_LINES\nattribute vec3 aNext;\nattribute vec2 aPoint;\nvarying vec2 vPoint;\nvarying float vLength;\nuniform float uAspect;\nuniform float uLwd;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  \n#ifndef IS_BRUSH\n#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG) || defined(USE_ENVMAP)\n  vPosition = mvMatrix * vec4(aPos, 1.);\n#endif\n  \n#ifndef FIXED_QUADS\n  gl_Position = prMatrix * vPosition;\n#endif\n#endif // !IS_BRUSH\n  \n#ifdef IS_POINTS\n  gl_PointSize = POINTSIZE;\n#endif\n  \n  vCol = aCol;\n  \n// USE_ENVMAP implies NEEDS_VNORMAL\n\n#ifdef NEEDS_VNORMAL\n  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\n#endif\n\n#ifdef USE_ENVMAP\n  vReflection = normalize(reflect(vPosition.xyz/vPosition.w, \n                        normalize(vNormal.xyz/vNormal.w)));\n#endif\n  \n#ifdef IS_TWOSIDED\n#ifdef HAS_NORMALS\n  /* normz should be calculated *after* projection */\n  normz = (invPrMatrix*vNormal).z;\n#else\n  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n  pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n  pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n  normz = pos1.x*pos2.y - pos1.y*pos2.x;\n#endif\n#endif // IS_TWOSIDED\n  \n#ifdef NEEDS_VNORMAL\n  vNormal = vec4(normalize(vNormal.xyz/vNormal.w), 1);\n#endif\n  \n#if defined(HAS_TEXTURE) || defined(IS_TEXT)\n  vTexcoord = aTexcoord;\n#endif\n  \n#if defined(FIXED_SIZE) && !defined(ROTATING)\n  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w;\n  gl_Position = pos + vec4(aOfs*textScale, 0.);\n#endif\n  \n#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\n  vec4 pos = mvMatrix * vec4(aPos, 1.);\n  pos = pos/pos.w + vec4(aOfs,  0.);\n  gl_Position = prMatrix*pos;\n#endif\n  \n#ifdef FAT_LINES\n  /* This code was inspired by Matt Deslauriers' code in \n   https://mattdesl.svbtle.com/drawing-lines-is-hard */\n  vec2 aspectVec = vec2(uAspect, 1.0);\n  mat4 projViewModel = prMatrix * mvMatrix;\n  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n  currentProjected = currentProjected/currentProjected.w;\n  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n  vec2 currentScreen = currentProjected.xy * aspectVec;\n  vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n  float len = uLwd;\n  vec2 dir = vec2(1.0, 0.0);\n  vPoint = aPoint;\n  vLength = length(nextScreen - currentScreen)/2.0;\n  vLength = vLength/(vLength + len);\n  if (vLength > 0.0) {\n    dir = normalize(nextScreen - currentScreen);\n  }\n  vec2 normal = vec2(-dir.y, dir.x);\n  dir.x /= uAspect;\n  normal.x /= uAspect;\n  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n  gl_Position = currentProjected + offset;\n#endif\n  \n#ifdef IS_BRUSH\n  gl_Position = vec4(aPos, 1.);\n#endif\n}","fragmentShader":"#line 2 2\n// File 2 is the fragment shader\n#ifdef GL_ES\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n#endif\nvarying vec4 vCol; // carries alpha\nvarying vec4 vPosition;\n#if defined(HAS_TEXTURE) || defined (IS_TEXT)\nvarying vec2 vTexcoord;\nuniform sampler2D uSampler;\n#endif\n\n#ifdef HAS_FOG\nuniform int uFogMode;\nuniform vec3 uFogColor;\nuniform vec4 uFogParms;\n#endif\n\n#if defined(IS_LIT) && !defined(FIXED_QUADS)\nvarying vec4 vNormal;\n#endif\n\n#if NCLIPPLANES > 0\nuniform vec4 vClipplane[NCLIPPLANES];\n#endif\n\n#if NLIGHTS > 0\nuniform mat4 mvMatrix;\n#endif\n\n#ifdef IS_LIT\nuniform vec3 emission;\nuniform float shininess;\n#if NLIGHTS > 0\nuniform vec3 ambient[NLIGHTS];\nuniform vec3 specular[NLIGHTS]; // light*material\nuniform vec3 diffuse[NLIGHTS];\nuniform vec3 lightDir[NLIGHTS];\nuniform bool viewpoint[NLIGHTS];\nuniform bool finite[NLIGHTS];\n#endif\n#endif // IS_LIT\n\n#ifdef IS_TWOSIDED\nuniform bool front;\nvarying float normz;\n#endif\n\n#ifdef FAT_LINES\nvarying vec2 vPoint;\nvarying float vLength;\n#endif\n\n#ifdef USE_ENVMAP\nvarying vec3 vReflection;\n#endif\n\nvoid main(void) {\n  vec4 fragColor;\n#ifdef FAT_LINES\n  vec2 point = vPoint;\n  bool neg = point.y < 0.0;\n  point.y = neg ? (point.y + vLength)/(1.0 - vLength) :\n                 -(point.y - vLength)/(1.0 - vLength);\n#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\n  if (neg && length(point) <= 1.0) discard;\n#endif\n  point.y = min(point.y, 0.0);\n  if (length(point) > 1.0) discard;\n#endif // FAT_LINES\n  \n#ifdef ROUND_POINTS\n  vec2 coord = gl_PointCoord - vec2(0.5);\n  if (length(coord) > 0.5) discard;\n#endif\n  \n#if NCLIPPLANES > 0\n  for (int i = 0; i < NCLIPPLANES; i++)\n    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\n#endif\n    \n#ifdef FIXED_QUADS\n    vec3 n = vec3(0., 0., 1.);\n#elif defined(IS_LIT)\n    vec3 n = normalize(vNormal.xyz);\n#endif\n    \n#ifdef IS_TWOSIDED\n    if ((normz <= 0.) != front) discard;\n#endif\n\n#ifdef IS_LIT\n    vec3 eye = normalize(-vPosition.xyz/vPosition.w);\n    vec3 lightdir;\n    vec4 colDiff;\n    vec3 halfVec;\n    vec4 lighteffect = vec4(emission, 0.);\n    vec3 col;\n    float nDotL;\n#ifdef FIXED_QUADS\n    n = -faceforward(n, n, eye);\n#endif\n    \n#if NLIGHTS > 0\n    for (int i=0;i<NLIGHTS;i++) {\n      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\n      lightdir = lightDir[i];\n      if (!viewpoint[i])\n        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n      if (!finite[i]) {\n        halfVec = normalize(lightdir + eye);\n      } else {\n        lightdir = normalize(lightdir - vPosition.xyz/vPosition.w);\n        halfVec = normalize(lightdir + eye);\n      }\n      col = ambient[i];\n      nDotL = dot(n, lightdir);\n      col = col + max(nDotL, 0.) * colDiff.rgb;\n      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\n      lighteffect = lighteffect + vec4(col, colDiff.a);\n    }\n#endif\n    \n#else // not IS_LIT\n    vec4 colDiff = vCol;\n    vec4 lighteffect = colDiff;\n#endif\n    \n#ifdef IS_TEXT\n    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n#endif\n    \n#ifdef HAS_TEXTURE\n\n// These calculations use the definitions from \n// https://docs.gl/gl3/glTexEnv\n\n#ifdef USE_ENVMAP\n    float m = 2.0 * sqrt(dot(vReflection, vReflection) + 2.0*vReflection.z + 1.0);\n    vec4 textureColor = texture2D(uSampler, vReflection.xy / m + vec2(0.5, 0.5));\n#else\n    vec4 textureColor = texture2D(uSampler, vTexcoord);\n#endif\n\n#ifdef TEXTURE_rgb\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(textureColor.rgb, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*vec4(textureColor.rgb, 1.);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb, lighteffect.a);\n#endif\n\n#endif //TEXTURE_rgb\n        \n#ifdef TEXTURE_rgba\n\n#ifdef TEXMODE_replace\n// already done\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = lighteffect*textureColor;\n#endif\n\n#ifdef TEXMODE_decal\n    textureColor = vec4((1. - textureColor.a)*lighteffect.rgb) +\n                     textureColor.a*textureColor.rgb, \n                     lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - textureColor.rgb) * lighteffect.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(lighteffect.rgb + textureColor.rgb,\n                    lighteffect.a*textureColor.a);\n#endif\n    \n#endif //TEXTURE_rgba\n    \n#ifdef TEXTURE_alpha\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(lighteffect.rgb, textureColor.a);\n#endif \n\n#if defined(TEXMODE_modulate) || defined(TEXMODE_blend) || defined(TEXMODE_add)\n    textureColor = vec4(lighteffect.rgb, lighteffect.a*textureColor.a);\n#endif\n \n#endif\n    \n// The TEXTURE_luminance values are not from that reference    \n#ifdef TEXTURE_luminance\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, lighteffect.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, lighteffect.a);\n#endif\n\n#endif // TEXTURE_luminance\n \n    \n#ifdef TEXTURE_luminance_alpha\n    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n\n#if defined(TEXMODE_replace) || defined(TEXMODE_decal)\n    textureColor = vec4(luminance, luminance, luminance, textureColor.a);\n#endif \n\n#ifdef TEXMODE_modulate\n    textureColor = vec4(luminance*lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_blend\n    textureColor = vec4((1. - luminance)*lighteffect.rgb,\n                        textureColor.a*lighteffect.a);\n#endif\n\n#ifdef TEXMODE_add\n    textureColor = vec4(luminance + lighteffect.rgb, \n                        textureColor.a*lighteffect.a);\n\n#endif\n\n#endif // TEXTURE_luminance_alpha\n    \n    fragColor = textureColor;\n\n#elif defined(IS_TEXT)\n    if (textureColor.a < 0.1)\n      discard;\n    else\n      fragColor = textureColor;\n#else\n    fragColor = lighteffect;\n#endif // HAS_TEXTURE\n    \n#ifdef HAS_FOG\n    // uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV/2))/(1+sin(FOV/2))\n    // In Exp and Exp2: use density = density/far\n    // fogF will be the proportion of fog\n    // Initialize it to the linear value\n    float fogF;\n    if (uFogMode > 0) {\n      fogF = (uFogParms.y - vPosition.z/vPosition.w)/(uFogParms.y - uFogParms.x);\n      if (uFogMode > 1)\n        fogF = mix(uFogParms.w, 1.0, fogF);\n      fogF = fogF*uFogParms.z;\n      if (uFogMode == 2)\n        fogF = 1.0 - exp(-fogF);\n      // Docs are wrong: use (density*c)^2, not density*c^2\n      // https://gitlab.freedesktop.org/mesa/mesa/-/blob/master/src/mesa/swrast/s_fog.c#L58\n      else if (uFogMode == 3)\n        fogF = 1.0 - exp(-fogF*fogF);\n      fogF = clamp(fogF, 0.0, 1.0);\n      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\n    } else gl_FragColor = fragColor;\n#else\n    gl_FragColor = fragColor;\n#endif // HAS_FOG\n    \n}","players":[],"webGLoptions":{"preserveDrawingBuffer":true}},"evals":[],"jsHooks":[]}</script>
]
---

# LDA &amp; QDA based on all untransformed variables :

.panelset[
.panel[.panel-name[ .red[LDA]]

.scroll-1000[


```r
lda(My.data[,-5],My.data$y)
```

```
## Call:
## lda(My.data[, -5], My.data$y)
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          CFTD        NITA     CATL     CANS
## 0 -0.06904762 -0.08142857 1.366667 0.437619
## 1  0.23520000  0.05560000 2.593600 0.426800
## 
## Coefficients of linear discriminants:
##             LD1
## CFTD  0.6612498
## NITA  4.3935204
## CATL  0.8872152
## CANS -1.1785089
```
]

]

.panel[.panel-name[ .red[Performance]]




.red[Training Set Performance]

```r
table(Actual = My.data[,5], Predicted = predict(lda(My.data[,-5],My.data$y))$class)
```

```
##       Predicted
## Actual  0  1
##      0 18  3
##      1  1 24
```

.red[AER Estimate (Cross Validated)]

```r
aer(My.data[,5], lda_Model.8$class)
```

```
## [1] 0.1304348
```
]
.panel[.panel-name[ .red[QDA]]

```r
qda(My.data[,-5],My.data$y)
```

```
## Call:
## qda(My.data[, -5], My.data$y)
## 
## Prior probabilities of groups:
##         0         1 
## 0.4565217 0.5434783 
## 
## Group means:
##          CFTD        NITA     CATL     CANS
## 0 -0.06904762 -0.08142857 1.366667 0.437619
## 1  0.23520000  0.05560000 2.593600 0.426800
```

]

.panel[.panel-name[ .red[Performance]]



.red[Training Set Performance]

```r
table(Actual = My.data[,5], Predicted = predict(qda(My.data[,-5],My.data$y))$class)
```

```
##       Predicted
## Actual  0  1
##      0 19  2
##      1  1 24
```

.red[AER Estimate (Cross Validated)]

```r
aer(My.data[,5], qda_Model.8$class)
```

```
## [1] 0.1086957
```


.red[ Best till now! ]
]
]
---

class: inverse, center, middle
background-image: url("fa_cover.jpeg")
background-size: cover

#Factor Analysis
---
# Factor Analysis :

* It is used to identify the underlying structure or patterns in a set of variables and to reduce their complexity into a smaller number of factors or components. 

--

* But to proceed with factor analysis, we need to first test whether the variables are actually related. i.e, whether the Correlation matrix of the variables is an Identity matrix. 

--

* For that we will use **Bartlett Test of Sphericity**. The hypothesis is `\(H_0\)`: `\(R=I\)` vs. `\(H_1:\)` Not `\(H_0\)`
Where, `\(R\)` is the population correlation matrix.          
* The test statistic is given by - 
   `$$−log(det(R^*))\frac{(N−1−(2p+5))}{6}$$`
Where, `\(R^*\)` is the sample correlation matrix. `\(N\)` is the sample size, and `\(p\)` is the number of variables.  
It has asymptotic `\(\chi^2\)` distribution with d.f  `\(\frac{p(p-1)}{2}\)`. It is sensitive to deviation from normality. 

---

# Factor Analysis :

.panelset[
.panel[.panel-name[ .red[Bartlett's Test]]



* Bartlett's Test of Sphericity ! 


```r
cortest.bartlett(My.data_trans4[,-5])
```

```
## $chisq
## [1] 88.4141
## 
## $p.value
## [1] 6.467218e-17
## 
## $df
## [1] 6
```

.green[Thus, Bartlett's test is rejected !]

]


.panel[.panel-name[Principal Component Method]

* .green[Using Principal Component Method &amp; Varimax Rotation :]

.scroll-1000[

```r
fc &lt;- fa((My.data_trans4[,-5]), nfactors = 2,rotate = "varimax",fm = "pa")
fc$loadings
```

```
## 
## Loadings:
##            PA1    PA2   
## CFTD_Trans  1.035 -0.122
## NITA_Trans  0.860       
## CATL_Trans  0.598  0.343
## CANS_Trans         0.496
## 
##                  PA1   PA2
## SS loadings    2.169 0.379
## Proportion Var 0.542 0.095
## Cumulative Var 0.542 0.637
```

```r
fc$communality
```

```
## CFTD_Trans NITA_Trans CATL_Trans CANS_Trans 
##  1.0866453  0.7393737  0.4755452  0.2465000
```
]

]

.panel[.panel-name[ .red[Maximum Likelihood Method]]

* .green[Using Maximum Likelihood Method &amp; Varimax Rotation :]

.scroll-1000[

```r
fc_n &lt;- fa((My.data_trans4[,-5]), nfactors = 2,rotate = "varimax", fm = "ml")
fc_n$loadings
```

```
## 
## Loadings:
##            ML1    ML2   
## CFTD_Trans  0.993       
## NITA_Trans  0.893       
## CATL_Trans  0.598  0.152
## CANS_Trans         0.997
## 
##                  ML1   ML2
## SS loadings    2.143 1.026
## Proportion Var 0.536 0.257
## Cumulative Var 0.536 0.792
```

```r
fc_n$communality
```

```
## CFTD_Trans NITA_Trans CATL_Trans CANS_Trans 
##  0.9950031  0.7985905  0.3802334  0.9950001
```
]

]

.panel[.panel-name[ .red[FA Diagram]]

.pull-left[


.red[For Principle Component Method :] 

![](mva_presentation_files/figure-html/unnamed-chunk-102-1.png)&lt;!-- --&gt;

]

.pull-right[

.red[For Maximum Likelihood Method :]

![](mva_presentation_files/figure-html/unnamed-chunk-103-1.png)&lt;!-- --&gt;

]
]

]

---

# Rotation Doesnot Change Fitted-Matrix :

.panelset[
.panel[.panel-name[Fitted-Matrix]

.red[Fitted Matrix with no rotation :]

```
##            CFTD_Trans NITA_Trans CATL_Trans CANS_Trans
## CFTD_Trans      1.000      0.889      0.579     -0.063
## NITA_Trans      0.889      1.000      0.531      0.008
## CATL_Trans      0.579      0.531      1.000      0.170
## CANS_Trans     -0.063      0.008      0.170      1.000
```

.red[Fitted Matrix with Varimax rotation :]

```
##            CFTD_Trans NITA_Trans CATL_Trans CANS_Trans
## CFTD_Trans      1.000      0.889      0.579     -0.063
## NITA_Trans      0.889      1.000      0.531      0.008
## CATL_Trans      0.579      0.531      1.000      0.170
## CANS_Trans     -0.063      0.008      0.170      1.000
```

.green[Exactly Same !]

]

.panel[.panel-name[Graphical Illustration]

&lt;img src="mva_presentation_files/figure-html/unnamed-chunk-106-1.png" style="display: block; margin: auto;" /&gt;
]

]


---

class: center, middle
background-image: url("explo.jpeg")
background-size: cover
 
# Further Exploration
---

# Logistic regression :

* In LDA, QDA, we assume that **X** has mixture gaussian distribution and groupwise it has multivariate normal distribution.

--

* But in Logistic regression, we assume `\(X_{p\times1}\)` to be non-stochastic and we model `$$P_r(Y=1|x_1,x_2,...,x_p)=\frac{e^{\beta_0+\beta_1 x_1+...+\beta_p x_p}}{1 + e^{\beta_0+\beta_1 x_1+...+\beta_p x_p}}$$`
Where, `\(\beta_0,\beta_1,...,\beta_p\)` are the parameters of the model.


---

# Fitting Logistic Regression Model :

.panelset[
.panel[.panel-name[ .red[Fitted Model]]
.scroll-1000[

```r
Logistic_Model.10 &lt;- glm(y ~.,data = My.data,family = binomial(link = "logit"))
summary(Logistic_Model.10)
```

```
## 
## Call:
## glm(formula = y ~ ., family = binomial(link = "logit"), data = My.data)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -2.30416  -0.44545   0.00725   0.49102   2.62396  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)   
## (Intercept)   -5.320      2.366  -2.248  0.02459 * 
## CFTD           7.138      6.002   1.189  0.23433   
## NITA          -3.703     13.670  -0.271  0.78647   
## CATL           3.415      1.204   2.837  0.00455 **
## CANS          -2.968      3.065  -0.968  0.33286   
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 63.421  on 45  degrees of freedom
## Residual deviance: 27.443  on 41  degrees of freedom
## AIC: 37.443
## 
## Number of Fisher Scoring iterations: 7
```
]
]
.panel[.panel-name[ .red[Model Evaluation]]
.pull-bottom[
.green[Taking 0.5 as threshold value !]
]
.red[Training Set Performance]

```r
table(Actual= My.data$y,Predicted=ifelse(predict.glm(Logistic_Model.10,type = "response") &gt; 0.5,1,0))
```

```
##       Predicted
## Actual  0  1
##      0 18  3
##      1  1 24
```
.red[AER Estimate(Cross Validated)]


```
## [1] 0.1086957
```
.green[Again, we are getting 10.86% estimated AER !]
]
]

---

## Profile Analysis:

- Profile Analysis is a multivariate data analysis technique that is applicable to situations in which p treatments are administrated to two or more groups of subjects.

-  The question of equality of mean vectors is divided into several specific questions such as 

 1.Are the population profiles parallel?
 
 2.Are they coincident? (Assuming they are parallel)
 
 3.Are the profiles level? (Assuming they are  coincident)

- **Assumptions:**

 &gt;- The test scores should have a multivariate normal distribution.
  
--

 *  .green[We can transform the data to retain multivariate normality]

--

 &gt;- Homogeneity of the variance covariance matrix of test scores.
 
--

 *  .red[Box-M Test rejected homogeneity assumption.]

--

 &gt;-  .blue[**So,We cannot perform Profile Analysis here !!!**]


---

# Summary : 

.pull-left[

* From EDA we have seen that, .red[CFTD, NITA and CATL are well separating bankrupt firms from financially sound firms]. From Factor analysis, we have got that these three are contributing to the first factor and CANS is contributing to the second factor.

* Also from EDA, we have seen that .red[CFTD and NITA are very highly correlated.]

* Plotting first three principal components, we visualized that .red[the data is well separated], so we applied LDA or QDA even without multivariate normality.

]

.pull-right[

* Finally, we have seen .red[QDA to the original data and Logistic regression] are yielding lowest AER(estimated)( 11% approx.).

* Further, if we only take .red[transformed NITA and CATL], then also we are not sacrificing much on AER(estimated)(13% approx.).  
]

---

class: center, middle
background-image: url("Thank.jpeg")
background-size: cover

#Thank You



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
